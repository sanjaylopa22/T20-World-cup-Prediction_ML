# -*- coding: utf-8 -*-
"""Arnab_world_cup_winner_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15BopsC1cx21TeKN31aWgm4tM7xTc75cY
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.ticker as ticker
import matplotlib.ticker as plticker
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier

world_cup = pd.read_csv("world_cup_t20_dataset.csv")
results = pd.read_csv('final.csv', index_col = [0])

results.info

n = 1
results = results.iloc[:,:-n]
print(results)

results.info

results.head()

results.isnull().sum()

df = results.dropna()
df.reset_index(drop=True)

df.isnull().sum()

df.head()

df.info()

df['Margin'].value_counts

df['Margin'].unique()

new_df = df[(df['Team_1'] == 'India') | (df['Team_2'] == 'India')]
india = new_df.iloc[:]
india.head()

year = []
for row in india['Date']:
    year.append(int(row[7:]))
india ['match_year']= year
india_2010 = india[india.match_year >= 10]
india_2010.count()

worldcup_teams = ['England', 'South Africa', 'Netherlands', 'Zimbabwe','Pakistan', 'New Zealand', 'Sri Lanka', 'Afghanistan','Australia', 'Bangladesh', 'India', 'Ireland']
df_teams_1 = df[df['Team_1'].isin(worldcup_teams)]
df_teams_2 = df[df['Team_2'].isin(worldcup_teams)]
df_teams = pd.concat((df_teams_1, df_teams_2))
df_teams.drop_duplicates()
df_teams.count()

df_teams_2010 = df_teams.drop(['Date','Margin', 'Ground'], axis=1)
df_teams_2010.head()

df_teams_2010 = df_teams_2010.reset_index(drop=True)
df_teams_2010.loc[df_teams_2010.Winner == df_teams_2010.Team_1,'winning_team']=1
df_teams_2010.loc[df_teams_2010.Winner == df_teams_2010.Team_2, 'winning_team']=2
df_teams_2010 = df_teams_2010.drop(['winning_team'], axis=1)

df_teams_2010.head()

#convert team-1 and team-2 from categorical variables to continous inputs 
# Get dummy variables
final = pd.get_dummies(df_teams_2010, prefix=['Team_1', 'Team_2'], columns=['Team_1', 'Team_2'])

# Separate X and y sets
X = final.drop(['Winner'], axis=1)
# print(X)
y = final["Winner"]


# Separate train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30, random_state=42)

final.head()

rf = RandomForestClassifier(n_estimators=100, max_depth=20,random_state=1) 
rf.fit(X_train, y_train)
score = rf.score(X_train, y_train)
score2 = rf.score(X_test, y_test)
print("Training set accuracy: ", '%.3f'%(score)) 
print("Test set accuracy: ", '%.3f'%(score2))

classifier= KNeighborsClassifier(n_neighbors=5, metric='minkowski', p=2 )  
classifier.fit(X_train, y_train)
score = classifier.score(X_train, y_train)
score2 = classifier.score(X_test, y_test)
print("Training set accuracy: ", '%.3f'%(score)) 
print("Test set accuracy: ", '%.3f'%(score2))

from sklearn.svm import SVC # "Support vector classifier"  
classifier_svc = SVC(kernel='linear', random_state=1)  
classifier_svc.fit(X_train, y_train)
score = classifier_svc.score(X_train, y_train)
score2 = classifier_svc.score(X_test, y_test)
print("Training set accuracy: ", '%.3f'%(score)) 
print("Test set accuracy: ", '%.3f'%(score2))

#adding ICC rankings
#the team which is positioned higher on the ICC Ranking will be considered "favourite" for the match
#and therefore, will be positioned under the "Team_1" column

# Loading new datasets
ranking = pd.read_csv('icc_rankings.csv') 
fixtures = pd.read_csv('fixtures.csv')

# List for storing the group stage games
pred_set = []

# fixtures.insert(1, 'first_position', fixtures['Team_1'].map(ranking.set_index('Team')['Position']))
# fixtures.insert(2, 'second_position', fixtures['Team_2'].map(ranking.set_index('Team')['Position']))

fixtures.info()

# fixtures = fixtures.iloc[:42, :]
# fixtures.tail()

fixtures.isnull().sum()

ranking

ranking.replace(to_replace=[r"\\t|\\n|\\r", "\t|\n|\r"], value=["",""], regex=True, inplace=True)

ranking

fixtures.replace(to_replace=[r"\\t|\\n|\\r", "\t|\n|\r"], value=["",""], regex=True, inplace=True)

fixtures['Team_1'].unique()

fixtures['Team_2'].unique()

# # for i in fixtures['Team_1']:
fixtures['Team_1'] = fixtures['Team_1'].str.strip()
fixtures['Team_2'] = fixtures['Team_2'].str.strip()
ranking['Team'] = ranking['Team'].str.strip()

fixtures.insert(1, 'first_position', fixtures['Team_1'].map(ranking.set_index('Team')['Position']))
fixtures.insert(2, 'second_position', fixtures['Team_2'].map(ranking.set_index('Team')['Position']))

fixtures.isnull().sum()

fixtures

fixtures = fixtures.iloc[:42, :]
fixtures.tail()

fixtures

for index, row in fixtures.iterrows():
    if row['first_position'] < row['second_position']:
        pred_set.append({'Team_1': row['Team_1'], 'Team_2': row['Team_2'], 'winning_team': None})
    else:
        pred_set.append({'Team_1': row['Team_2'], 'Team_2': row['Team_1'], 'winning_team': None})
        
pred_set = pd.DataFrame(pred_set)
backup_pred_set = pred_set
pred_set.head()

# Get dummy variables and drop winning_team column
pred_set = pd.get_dummies(pred_set, prefix=['Team_1', 'Team_2'], columns=['Team_1', 'Team_2'])

# Add missing columns compared to the model's training dataset
missing_cols = set(final.columns) - set(pred_set.columns)
for c in missing_cols:
    pred_set[c] = 0
pred_set = pred_set[final.columns]


pred_set = pred_set.drop(['Winner'], axis=1)
pred_set.head()

# predictions = classifier.predict(pred_set)
# for i in range(fixtures.shape[0]):
#     print(backup_pred_set.iloc[i, 1] + " and " + backup_pred_set.iloc[i, 0])
#     if predictions[i] == 1:
#         print("Winner: " + backup_pred_set.iloc[i, 1])
    
#     else:
#         print("Winner: " + backup_pred_set.iloc[i, 0])
#     print("")

#group matches 
predictions = rf.predict(pred_set)
ctr = 0
winner = []
for i in range(fixtures.shape[0]):
    print(backup_pred_set.iloc[i, 1] + " and " + backup_pred_set.iloc[i, 0])
    if predictions[i] == 1:
        team =  backup_pred_set.iloc[i, 1]
        print("Winner: " + backup_pred_set.iloc[i, 1])
        winner.append(team)
#         ctr = winn[team]
#         winn[team] = ctr + 1
    else:
        print("Winner: " + backup_pred_set.iloc[i, 0])
        winner.append(backup_pred_set.iloc[i, 0])
    print("")

winner

worldcup_teams = ['England', 'South Africa', 'Netherlands', 'Zimbabwe','Pakistan', 'New Zealand', 'Sri Lanka', 'Afghanistan','Australia', 'Bangladesh', 'India', 'Ireland']

dct = {}
for i in worldcup_teams:
    ctr = winner.count(i)
    dct[i] = ctr

dct

ranking

# from collections import OrderedDict
# lst = OrderedDict(sorted(dct.items()))

# # for i in dct:
# lst   
# sorted_value_index = np.argsort(dct.values())
# dictionary_keys = list(dct.keys())
# sorted_dict = {dictionary_keys[i]: sorted(
#     dct.values())[i] for i in range(len(dictionary_keys))}

# print(sorted_dict)
# res = OrderedDict(reversed(list(sorted_dict.items())))
# res
# import itertools
# res = dict(itertools.islice(res.items(), 4))

# res

# res = dict(reversed(list(sorted_dict.items())))
# print(res)



# from collections import OrderedDict
 
# dict = {'ravi': '10', 'rajnish': '9',
#         'sanjeev': '15', 'yash': '2', 'suraj': '32'}
# dict1 = OrderedDict(sorted(dct.items()))
# print(dict1)

# dict1 = {1: 1, 2: 9, 3: 4}
sorted_values = sorted(dct.values(),reverse=True) # Sort the values
sorted_dict = {}

for i in sorted_values:
    for k in dct.keys():
        if dct[k] == i:
            sorted_dict[k] = dct[k]

print(sorted_dict)

import itertools
res = dict(itertools.islice(sorted_dict.items(), 4))
res

semi = []
for i in res.keys():
    semi.append(i)
semi

final_semi = [('India', 'England'),('Sri Lanka','Pakistan')]

# clean_and_predict(semi, ranking, final, rf)

# ranking

# new_dict= {}
# for i in semi:
#     new_dict[i] = ranking[Team]('Postion')

# dicti = {}
# for i in semi:
#     select = ranking.loc[ranking['Team'] == i]
# #     print(select)
#     dicti[select["Position"]] = ranking.loc[ranking['Team'] == i]
    
# dicti

# for (columnName, columnData) in ranking.iteritems():
    
#     print('Colunm Name : ', columnName)
#     print('Column Contents : ', columnData.values)
#     if(columnName=="Position"):
#         d

def clean_and_predict(matches, ranking, final, logreg):

    # Initialization of auxiliary list for data cleaning
    positions = []

    # Loop to retrieve each team's position according to ICC ranking
    for match in matches:
        positions.append(ranking.loc[ranking['Team'] == match[0],'Position'].iloc[0])
        positions.append(ranking.loc[ranking['Team'] == match[1],'Position'].iloc[0])
    
    # Creating the DataFrame for prediction
    pred_set = []

    # Initializing iterators for while loop
    i = 0
    j = 0

    # 'i' will be the iterator for the 'positions' list, and 'j' for the list of matches (list of tuples)
    while i < len(positions):
        dict1 = {}

        # If position of first team is better then this team will be the 'Team_1' team, and vice-versa
        if positions[i] < positions[i + 1]:
            dict1.update({'Team_1': matches[j][0], 'Team_2': matches[j][1]})
        else:
            dict1.update({'Team_1': matches[j][1], 'Team_2': matches[j][0]})

        # Append updated dictionary to the list, that will later be converted into a DataFrame
        pred_set.append(dict1)
        i += 2
        j += 1
        
        # Convert list into DataFrame
    pred_set = pd.DataFrame(pred_set)
    backup_pred_set = pred_set

    # Get dummy variables and drop winning_team column
    pred_set = pd.get_dummies(pred_set, prefix=['Team_1', 'Team_2'], columns=['Team_1', 'Team_2'])

    # Add missing columns compared to the model's training dataset
    missing_cols2 = set(final.columns) - set(pred_set.columns)
    for c in missing_cols2:
        pred_set[c] = 0
    pred_set = pred_set[final.columns]

    pred_set = pred_set.drop(['Winner'], axis=1)
    # Predict!
    predictions = logreg.predict(pred_set)
    for i in range(len(pred_set)):
        print(backup_pred_set.iloc[i, 1] + " and " + backup_pred_set.iloc[i, 0])
        if predictions[i] == 1:
            print("Winner: " + backup_pred_set.iloc[i, 1])
        else:
            print("Winner: " + backup_pred_set.iloc[i, 0])
        print("")

clean_and_predict(final_semi, ranking, final, rf)

finals_team = [('India', 'Pakistan')]

clean_and_predict(finals_team, ranking, final, rf)

# ranking